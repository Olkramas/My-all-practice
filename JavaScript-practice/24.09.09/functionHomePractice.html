<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        var a = 1;
        let sum = 0;
        let n = 50;

        function sum1(min, max) {
            let sum = 0;
            for(let i=min; i<=max; i++) {
                sum += i;
            }
            return sum;
        }
        console.log(sum1(1, 10));
        console.log(sum1());

        //익명 함수 선언
        let plus = function(num1, num2) {
            return num1 + num2;
        }
        console.log("익명 함수 선언" + plus(1, 2));
        
        //즉시 호출 함수
        let count = function()  {
            let c = 0;
            return function() {
                return ++c;
            }
        }();
        /*
        외부함수의 지역변수인 c는 함수가 선언됨과 동시에 0으로 선언됨.
        이 함수를 사용하면서 함수가 불러와지면, 외부 함수의 재할당은 실행되지 않음. 처음 한번만 실행됨.
        그리고 내부 함수를 리턴하게 되는데, c에 대한 참조 경로만 저장되고,
        실제 c값은 클로져에 저장됨.
        그리고 해당 함수를 실행할 때, return보다 먼저 ++c가 실행되어 수가 올라가는 것.
        */
        console.log(count());
        console.log(count());
        console.log(count);

        //증감연산자 위치
        let cnt = 0;
        let cnt2 = 0;
        console.log(cnt++);
        console.log(++cnt2);        //콘솔 출력전에 숫자가 1올라간 모습.

        //콜백함수
        function done(coffee) {
            console.log(coffee + " 준비완료");
        }
        function order(coffee, callback) {
            console.log(coffee + "주문접수");
            //setTimeout(() => {callback(coffee);}, 3000);
            setTimeout(function() {
                return callback(coffee);
            }, 3000);
        }
        order("아아아", done);

        //화살표 함수변환 연습
        let sum2 = (a,b) => a + b;
        let square = (x) => x * x;
        let greet = () => "hello";
        let multiply = (a, b) => {
            let result = a * b;
            return result;
        }
        let result = (() => {
            let x = 10;
            return x;
        })();
        let person = {
            name: "John",
            greet: function() {
                console.log("hello, my name is " + this.name);
            }
        };
        /*
        greet: () => {
            console.log("hello, my name is " + this.name);
        }
            화살표 함수에서 this.는 객체 내부에서 this.name을 찾는게 아님.
            윈도우(상위 스코프)에서 받게됨. 그러나 윈도우에는 name이 없어서 값이 안나옴.
            결론. 화살표 함수에서의 this.는 객체 내부가 아닌 상위 스코프에서 받기때문에
            객체의 메소드에 사용하기에는 부적적하다.
        */
        console.log(person.greet());

        //펼침연산자
        let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        sum3(...arr);

        function sum3(x, y, z,...nums) {
            let sum = 0;
            sum = x + y + z;                    //변수 x,y,z는 먼저 더해서 할당을 해줘야함.
            for(let i=0; i<nums.length; i++) {
                sum += nums[i];
                console.log(sum);
            }
            console.log("합계는 " + sum);
        }
    </script>
</body>
</html>